
Complete Prompt for Hierarchical Heterogeneous Graph Neural Network with Survival Analysis

### INSTRUCTION
Generate a complete, production-ready implementation of a hierarchical heterogeneous graph neural network for multi-omics cancer subtyping with survival analysis. Create ALL files listed in the project structure below with full implementation code. The system should process multi-omics data (mRNA, CNV, DNA methylation, miRNA) from a single cohort dataset to discover cancer subtypes using a two-level graph architecture, then evaluate these subtypes using survival data and c-index.

### PROJECT STRUCTURE TO GENERATE
Please create the following files with complete implementation:

cancer-subtyping-hgnn/
│
├── configs/
│   ├── model_config.yaml
│   ├── data_config.yaml
│   ├── training_config.yaml
│   ├── pathway_config.yaml
│   └── survival_config.yaml
│
├── src/
│   ├── data_loading/
│   │   ├── __init__.py
│   │   ├── omics_loader.py
│   │   ├── mapping_loader.py
│   │   ├── pathway_loader.py
│   │   └── survival_loader.py
│   │
│   ├── graph_construction/
│   │   ├── __init__.py
│   │   ├── patient_graph.py
│   │   ├── inter_patient.py
│   │   ├── edge_builders.py
│   │   └── feature_engineering.py
│   │
│   ├── models/
│   │   ├── __init__.py
│   │   ├── hetero_gat.py
│   │   ├── survival_gnn.py
│   │   ├── layers/
│   │   │   ├── __init__.py
│   │   │   ├── attention.py
│   │   │   └── aggregation.py
│   │   └── components.py
│   │
│   ├── training/
│   │   ├── __init__.py
│   │   ├── trainer.py
│   │   ├── survival_trainer.py
│   │   ├── evaluator.py
│   │   └── callbacks.py
│   │
│   ├── survival_analysis/
│   │   ├── __init__.py
│   │   ├── c_index.py
│   │   ├── kaplan_meier.py
│   │   ├── cox_regression.py
│   │   ├── survival_utils.py
│   │   └── risk_stratification.py
│   │
│   ├── analysis/
│   │   ├── __init__.py
│   │   ├── clustering.py
│   │   ├── subtype_discovery.py
│   │   ├── cohort_statistics.py
│   │   ├── embedding_analysis.py
│   │   └── subtype_survival.py
│   │
│   ├── interpretation/
│   │   ├── __init__.py
│   │   ├── attention_analysis.py
│   │   ├── pathway_importance.py
│   │   ├── biomarker_extraction.py
│   │   └── survival_biomarkers.py
│   │
│   └── utils/
│       ├── __init__.py
│       ├── graph_utils.py
│       ├── constants.py
│       ├── logging_config.py
│       └── survival_metrics.py
│
├── main.py
├── requirements.txt
└── README.md

### DETAILED SPECIFICATIONS FOR EACH MODULE
1. DATA LOADING MODULE (src/data_loading/)
##### omics_loader.py

Load preprocessed omics data from preprocessedv3.py output
Support 4 modalities: mRNA, CNV, DNA methylation, miRNA
Use ALL features without selection (no top-k feature selection)
Return structured data format with patient IDs and feature matrices
Handle missing data appropriately
Implement batch loading for large datasets

##### mapping_loader.py

Load CSV mapping files dynamically at runtime
Support two mapping types:

methylation_to_gene.csv: CpG sites → Ensembl Gene IDs
mirna_to_gene.csv: miRNA → Target Genes (from TargetScan + miRTarBase)


Implement efficient lookup using dictionaries
Handle missing mappings gracefully
Cache loaded mappings for efficiency

##### pathway_loader.py

Load pathway annotations from cBioPortal, KEGG, and Reactome
Support gene-to-pathway mappings
Load alteration type definitions (amplified, deleted, mutated, overexpressed)
Merge pathway databases intelligently

##### survival_loader.py

Load survival data with columns: patient_id, survival_time, event (0=censored, 1=death)
Handle missing values appropriately
Convert time units if needed
Validate data integrity
Align with omics patient IDs
Create PyTorch tensors for survival analysis

2. GRAPH CONSTRUCTION MODULE (src/graph_construction/)
##### patient_graph.py

Implement PatientGraphBuilder class for Level 1 graphs
Create heterogeneous graph with 4 node types per patient
Node features: Use all preprocessed features from each omics modality
Edge construction:

mRNA ↔ CNV: Direct Ensembl ID matching
DNA methylation → Genes: Use loaded CSV mapping
miRNA → Genes: Use loaded CSV mapping


Use PyTorch Geometric heterogeneous graph structure
Support batch graph construction

##### inter_patient.py

Implement InterPatientGraphBuilder class for Level 2 network
Create patient-level nodes from aggregated patient graphs
Edge types:

Shared pathway alterations between patients
Gene-specific alterations (same alteration type in same genes)


Edge weight calculation based on:

Frequency of shared alterations
Pattern similarity metrics
Clinical significance scores


Implement edge pruning for computational efficiency

##### edge_builders.py

Modular edge construction functions
Support for multiple edge types
Edge weight computation utilities
Threshold-based edge filtering
Similarity metric implementations

3. MODELS MODULE (src/models/)
##### hetero_gat.py

Implement Heterogeneous Graph Attention Network (HeteroGAT)
Multi-level architecture:

Level 1: Intra-patient omics integration
Level 2: Inter-patient pathway relationships


Support variable number of attention heads
Include dropout and batch normalization
Return embeddings for clustering

##### survival_gnn.py

Extend HeteroGAT with survival prediction head
Implement multiple loss functions:

Cox partial likelihood loss
Ranking loss
Concordance loss


Support joint training with multiple objectives
Include risk score and hazard prediction heads

##### layers/attention.py

Custom multi-head attention mechanism for heterogeneous graphs
Type-specific transformations for different node/edge types
Attention weight computation and storage for interpretability
Support for edge features

##### layers/aggregation.py

Message passing implementations
Type-aware aggregation functions
Support for different reduction operations (mean, max, sum)
Neighborhood sampling for scalability

4. TRAINING MODULE (src/training/)
##### trainer.py

Implement UnsupervisedTrainer class for unsupervised learning
Support autoencoder and contrastive learning approaches
Extract embeddings for clustering
Implement training loop with early stopping

##### survival_trainer.py

Implement SurvivalAwareTrainer class
Joint training with multiple objectives:

Graph reconstruction/contrastive learning (weight: 0.3)
Clustering quality (weight: 0.3)
Survival prediction/C-index optimization (weight: 0.4)


Support for different survival loss functions
Implement gradient accumulation for large graphs

##### evaluator.py

Evaluation for single cohort analysis
Unsupervised metrics: Silhouette score, Davies-Bouldin index, Calinski-Harabasz index
If labels available: ARI, NMI
Clustering stability across runs
Consensus clustering evaluation

5. SURVIVAL ANALYSIS MODULE (src/survival_analysis/)
##### c_index.py

Calculate Harrell's C-index
Bootstrap confidence intervals (default: 1000 iterations)
Stratified C-index for subtype evaluation
Time-dependent C-index
Handle tied survival times appropriately

##### kaplan_meier.py

Fit KM curves for each subtype
Plot survival curves with confidence intervals
Perform pairwise and overall log-rank tests
Calculate median survival per subtype with CI
Survival probability at specific time points (1, 3, 5 years)

##### cox_regression.py

Univariate and multivariate Cox regression
Cox regression with subtypes as categorical variables
Calculate hazard ratios with confidence intervals
Test proportional hazards assumption
Generate Cox risk scores

##### risk_stratification.py

Stratify patients into risk groups (tertiles, median, optimal cutoff)
Find optimal cutoff using maximally selected rank statistics
Validate stratification with C-index and log-rank test
Generate risk group visualizations

6. ANALYSIS MODULE (src/analysis/)
##### clustering.py

Multiple clustering algorithms: Leiden, Louvain, K-means, Spectral
Optimize number of clusters if not specified
Compute clustering quality metrics
Implement consensus clustering

##### subtype_discovery.py

Discover subtypes from embeddings
Characterize subtypes with differential features
Generate subtype signatures
Validate subtype stability

##### subtype_survival.py

Comprehensive survival analysis per subtype
C-index for subtype stratification
Identify high-risk subtypes
Create survival heatmaps
Assess survival-distinct subtype stability

7. INTERPRETATION MODULE (src/interpretation/)
##### attention_analysis.py

Extract and visualize attention weights
Identify important omics connections
Patient-level attention patterns
Generate attention heatmaps

##### pathway_importance.py

Compute pathway-level importance scores
Rank pathways by contribution to predictions
Pathway enrichment analysis
Generate pathway-survival associations

##### biomarker_extraction.py

Identify top genes/features for each cancer subtype
Statistical significance testing
Export biomarker lists
Validate biomarkers with external databases

##### survival_biomarkers.py

Extract survival-associated features
Prognostic gene signatures
Time-dependent biomarker analysis
Multi-omics integration for biomarker discovery

8. CONFIGURATION FILES
##### model_config.yaml
yamlmodel:
  architecture: "SurvivalHeteroGAT"
  hidden_dims: [256, 128, 64]
  num_heads: [8, 4, 2]
  dropout: 0.2
  activation: "relu"
  
  objectives:
    predict_subtypes: true
    predict_survival: true
    num_subtypes: null  # Auto-detect or specify
    
  survival_head:
    type: "risk_score"
    hidden_layers: [32, 16]
    activation: "relu"
    
graph:
  level1:
    node_types: ["mRNA", "CNV", "methylation", "miRNA"]
    edge_types: ["mRNA-CNV", "methylation-gene", "miRNA-gene"]
  level2:
    edge_threshold: 0.5
    max_neighbors: 50
##### data_config.yaml
yamldata:
  processed_path: "data/processed/"
  mappings:
    methylation_gene: "data/mappings/methylation_to_gene.csv"
    mirna_gene: "data/mappings/mirna_to_gene.csv"
  
omics:
  modalities: ["mRNA", "CNV", "methylation", "miRNA"]
  use_all_features: true
  
analysis:
  mode: "unsupervised"
  cv_folds: 5
  stratified: true
  n_clusters: null
  clustering_method: "leiden"
##### training_config.yaml
yamltraining:
  epochs: 200
  batch_size: 32
  learning_rate: 0.001
  optimizer: "adam"
  scheduler:
    type: "cosine"
    warmup_epochs: 10
  early_stopping:
    patience: 20
    metric: "c_index"
    mode: "max"
  gradient_clip: 1.0
##### survival_config.yaml
yamlsurvival:
  data_path: "data/survival/survival_data.csv"
  time_unit: "months"
  
  analysis:
    calculate_c_index: true
    bootstrap_iterations: 1000
    confidence_level: 0.95
    
  kaplan_meier:
    time_points: [12, 36, 60]
    plot_confidence_intervals: true
    
  cox_regression:
    include_clinical_covariates: false
    test_proportional_hazards: true
    
  risk_stratification:
    method: "tertiles"
    validate_groups: true
    
  loss_functions:
    survival_loss: "cox"
    loss_weights:
      reconstruction: 0.3
      clustering: 0.3
      survival: 0.4
9. MAIN PIPELINE (main.py)
Create a comprehensive main.py that:

Loads all configurations
Loads omics and survival data
Loads mappings (CSV files)
Constructs patient graphs (Level 1)
Builds inter-patient network (Level 2)
Trains model (unsupervised or with survival)
Discovers/predicts subtypes
Performs complete survival analysis:

Calculates C-index with bootstrap CI
Performs Kaplan-Meier analysis
Conducts log-rank tests
Runs Cox regression
Stratifies risk groups


Extracts biomarkers and pathway importance
Generates comprehensive report with all results

10. REQUIREMENTS.txt
torch>=2.0.0
torch-geometric>=2.3.0
dgl>=1.0.0
numpy>=1.21.0
pandas>=1.3.0
scikit-learn>=1.0.0
lifelines>=0.27.0
scikit-survival>=0.20.0
matplotlib>=3.5.0
seaborn>=0.11.0
pyyaml>=6.0
tqdm>=4.62.0
networkx>=2.6.0
wandb
tensorboard
scipy>=1.7.0
statsmodels>=0.13.0
EXPECTED OUTPUTS
The system should produce:

##### Survival Metrics:

C-index with 95% confidence intervals
Time-dependent C-index curves
Log-rank test p-values


##### Subtype Results:

Patient-subtype assignments
Median survival per subtype with CI
Hazard ratios between subtypes
Kaplan-Meier curves


##### Biomarkers:

Top genes per subtype
Survival-associated pathways
Attention weight visualizations


##### Reports:

Comprehensive PDF/HTML report
CSV files with all metrics
Publication-ready figures


### IMPLEMENTATION REQUIREMENTS

Use PyTorch and PyTorch Geometric for graph neural networks
Implement proper error handling and logging
Include docstrings with type hints
Support both CPU and GPU computation
Handle edge cases (all censored, single subtype, etc.)
Ensure reproducibility with seed setting
Implement unit tests for critical functions
Use efficient data structures for large-scale data
Include progress bars for long operations
Cache intermediate results when appropriate

Generate complete, production-ready, well-documented code for ALL files listed above. Each file should be fully functional and ready to run on real multi-omics cancer data with survival information.